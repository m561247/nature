import libc
import crypto.types

type sha256_t = struct{
    types.mbedtls_sha256_context mbed_ctx
}

fn new():ptr<sha256_t> {
    var s = new sha256_t()
    
    types.mbedtls_sha256_init(&s.mbed_ctx)
    
    types.mbedtls_sha256_starts(&s.mbed_ctx, 0)

    return s
}

fn sha256_t.update([u8] input):ptr<sha256_t> {
    types.mbedtls_sha256_update(&self.mbed_ctx, (input as string).to_cstr(), input.len())
    return self
}

fn sha256_t.finish():[u8] {
    var output = vec_new<u8>(0, 32)  // SHA256 输出 32 字节
    types.mbedtls_sha256_finish(&self.mbed_ctx, output.ref())
    
    // 清理上下文
    types.mbedtls_sha256_free(&self.mbed_ctx)
    
    return output
}

fn sha256_t.hex():string {
    var output = vec_new<u8>(0, 32)  // SHA256 输出 32 字节
    types.mbedtls_sha256_finish(&self.mbed_ctx, output.ref())
    
    // 清理上下文
    types.mbedtls_sha256_free(&self.mbed_ctx)

    var hex_chars = "0123456789abcdef"
    [u8] result = []
    
    for i,v in output {
        var byte_val = output[i]
        var high = (byte_val >> 4) & 0x0F
        var low = byte_val & 0x0F
        result.push(hex_chars[high])
        result.push(hex_chars[low])
    }
    
    return result as string
}

fn hex(string input):string {
    return new().update(input as [u8]).hex()
}