=== test_nullable_type
--- main.n
import io

type connable = interface{}

fn main() {
    connable? maybe = null
    println(maybe)
    assert(maybe is null)
}


=== test_json_serialize_any
--- main.n
import http.client
import json
import http

fn test(any b):string! {
    return json.serialize(b)
}

type user_t = struct{
    string email
}

fn main() {
    any u = user_t{email = 'wwhacker@qq.com'}
    var str = json.serialize(u)
    println(str)
}

--- output.txt
{"email":"wwhacker@qq.com"}


=== test_url_encode
--- main.n
import net.url

fn main() {
    var encoded = url.encode("hello world")
    println(encoded)
    assert(encoded == 'hello+world')

    var encoded2 = url.encode("用户名=张三")
    println(encoded2)
    assert(encoded2 == '%E7%94%A8%E6%88%B7%E5%90%8D%3D%E5%BC%A0%E4%B8%89')
}

=== test_rem_div
--- main.n
fn dump(u8 i, u8 rem) {
    println(i, rem)
}

fn test(u8 i, string fill, u8 width):string {
    u8 base = 10
    [u8] result = []
    u8 rem = i % base
    println('rem ->', rem)

    u8 quotient = i / base
    println(quotient)

    return ''
}

fn main() {
    var s = test(12, ' ', 0)

    u8 a = 12
    var b = a * 10
    println(b)
}

--- output.txt
rem -> 2
1
120



=== test_uint_shift_right
--- main.n
fn random_u32(rawptr<u64> state):u32 {
    // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A
    *state ^= *state >> 12
    *state ^= *state << 25
    *state ^= *state >> 27
    return ((*state * 0x2545F4914F6CDD1D) >> 32) as u32
}

fn random_f32(rawptr<u64> state):f32 {
    // random float32 in [0,1)
    return (random_u32(state) >> 8) as f32 / 16777216.0
}


fn main():void! {
    u64 seed1 = 58494830515472664
    u32 a = random_u32(&seed1)
    println(a)
    assert(a == 2094371595)
}

=== test_octal
--- main.n
fn main() {
    var v = 0o755
    println(v)
    assert(v == 0755)
}

=== test_module_init
--- main.n
import syscall

var seed = syscall.SYS_GETPPID

fn main():void! {
    assert(seed == syscall.SYS_GETPPID)
    println(seed)
}

=== test_module_init2
--- main.n
import time
import syscall

var seed = time.now().timestamp()

fn main():void! {
    assert(seed > 0)
    println(seed)
}

=== test_udiv_urem
--- main.n
fn main():void! {
    u32 base = 10
    u32 i = 3102678087
    u32 rem = i % base
    println(rem)
    assert(rem == 7)

    u32 d = i / base
    println(d)
    assert(d == 310267808)
}

=== test_i16_cmp
--- main.n
fn dump(bool v) {
    println(v)
}

fn main():void! {
    i16 original_i16 = -12345
    i16 read_i16 = -12345

    dump(read_i16 == original_i16)
    assert(read_i16 == original_i16)
}


=== test_mem_write
--- main.n
import mem

fn main():void! {
    // Test Little Endian write functions

    // Test write_u8_le
    var u8_bytes = mem.write_u8_le(0x42)
    assert(u8_bytes.len() == 1)
    assert(u8_bytes[0] == 0x42)

    // Test write_u16_le
    var u16_bytes = mem.write_u16_le(0x1234)
    assert(u16_bytes.len() == 2)
    assert(u16_bytes[0] == 0x34) // low byte
    assert(u16_bytes[1] == 0x12) // high byte

    // Test write_u32_le
    var u32_bytes = mem.write_u32_le(0x12345678)
    assert(u32_bytes.len() == 4)
    assert(u32_bytes[0] == 0x78)
    assert(u32_bytes[1] == 0x56)
    assert(u32_bytes[2] == 0x34)
    assert(u32_bytes[3] == 0x12)

    // Test write_u64_le
    var u64_bytes = mem.write_u64_le(0x123456789ABCDEF0)
    assert(u64_bytes.len() == 8)
    assert(u64_bytes[0] == 0xF0)
    assert(u64_bytes[1] == 0xDE)
    assert(u64_bytes[2] == 0xBC)
    assert(u64_bytes[3] == 0x9A)
    assert(u64_bytes[4] == 0x78)
    assert(u64_bytes[5] == 0x56)
    assert(u64_bytes[6] == 0x34)
    assert(u64_bytes[7] == 0x12)

    // Test signed integer write functions
    var i8_bytes = mem.write_i8_le(-1)
    assert(i8_bytes.len() == 1)
    assert(i8_bytes[0] == 0xFF)

    var i16_bytes = mem.write_i16_le(-1)
    assert(i16_bytes.len() == 2)
    assert(i16_bytes[0] == 0xFF)
    assert(i16_bytes[1] == 0xFF)

    var i32_bytes = mem.write_i32_le(-1)
    assert(i32_bytes.len() == 4)
    assert(i32_bytes[0] == 0xFF)
    assert(i32_bytes[1] == 0xFF)
    assert(i32_bytes[2] == 0xFF)
    assert(i32_bytes[3] == 0xFF)

    var i64_bytes = mem.write_i64_le(-1)
    assert(i64_bytes.len() == 8)
    for int i = 0; i < 8; i += 1 {
        assert(i64_bytes[i] == 0xFF)
    }

    // Test Big Endian write functions

    // Test write_u16_be
    var u16_be_bytes = mem.write_u16_be(0x1234)
    assert(u16_be_bytes.len() == 2)
    assert(u16_be_bytes[0] == 0x12) // high byte
    assert(u16_be_bytes[1] == 0x34) // low byte

    // Test write_u32_be
    var u32_be_bytes = mem.write_u32_be(0x12345678)
    assert(u32_be_bytes.len() == 4)
    assert(u32_be_bytes[0] == 0x12)
    assert(u32_be_bytes[1] == 0x34)
    assert(u32_be_bytes[2] == 0x56)
    assert(u32_be_bytes[3] == 0x78)

    // Test write_u64_be
    var u64_be_bytes = mem.write_u64_be(0x123456789ABCDEF0)
    assert(u64_be_bytes.len() == 8)
    assert(u64_be_bytes[0] == 0x12)
    assert(u64_be_bytes[1] == 0x34)
    assert(u64_be_bytes[2] == 0x56)
    assert(u64_be_bytes[3] == 0x78)
    assert(u64_be_bytes[4] == 0x9A)
    assert(u64_be_bytes[5] == 0xBC)
    assert(u64_be_bytes[6] == 0xDE)
    assert(u64_be_bytes[7] == 0xF0)

    // Test read-write consistency - Little Endian
    u16 original_u16 = 0x1234
    var written_u16 = mem.write_u16_le(original_u16)
    var read_u16 = mem.read_u16_le(written_u16)
    assert(read_u16 == original_u16)

    u32 original_u32 = 0x12345678
    var written_u32 = mem.write_u32_le(original_u32)
    var read_u32 = mem.read_u32_le(written_u32)
    assert(read_u32 == original_u32)

    u64 original_u64 = 0x123456789ABCDEF0
    var written_u64 = mem.write_u64_le(original_u64)
    var read_u64 = mem.read_u64_le(written_u64)
    assert(read_u64 == original_u64)

    // Test read-write consistency - Big Endian
    u16 original_u16_be = 0x1234
    var written_u16_be = mem.write_u16_be(original_u16_be)
    var read_u16_be = mem.read_u16_be(written_u16_be)
    assert(read_u16_be == original_u16_be)

    u32 original_u32_be = 0x12345678
    var written_u32_be = mem.write_u32_be(original_u32_be)
    var read_u32_be = mem.read_u32_be(written_u32_be)
    assert(read_u32_be == original_u32_be)

    u64 original_u64_be = 0x123456789ABCDEF0
    var written_u64_be = mem.write_u64_be(original_u64_be)
    var read_u64_be = mem.read_u64_be(written_u64_be)
    assert(read_u64_be == original_u64_be)

    // Test signed integer read-write consistency
    i16 original_i16 = -12345
    var written_i16 = mem.write_i16_le(original_i16)
    var read_i16 = mem.read_i16_le(written_i16)
    assert(read_i16 == original_i16)

    i32 original_i32 = -123456789
    var written_i32 = mem.write_i32_le(original_i32)
    var read_i32 = mem.read_i32_le(written_i32)
    assert(read_i32 == original_i32)

    i64 original_i64 = -1234567890123456789
    var written_i64 = mem.write_i64_le(original_i64)
    var read_i64 = mem.read_i64_le(written_i64)
    assert(read_i64 == original_i64)

    println("All mem write function tests passed!")
}

=== test_const_select
--- main.n
const str = "hello"

fn main():void! {
    println(str.len())
    assert(str.len() == 5)
}

=== test_or_equal_and_equal
--- main.n
fn main():void! {
    var val = 18
    val |= 8
    println(val)
    assert(val == 26)

    val &= 8
    println(val)
    assert(val == 8)
}


=== test_base64
--- main.n
import base64

fn main() {
    var encode_str = base64.encode('hello world' as [u8]) as string
    println(encode_str)
    assert(encode_str == 'aGVsbG8gd29ybGQ=')

    var str = base64.decode(encode_str as [u8]) as string
    println(str)
    assert(str == 'hello world')
}

=== test_resolve_flow
--- main.n
fn int_to_hex(int val):u8 {
    if val >= 0 && val <= 9 {
        return '0'.char() + val as u8
    } else if val >= 10 && val <= 15 { // bug 就是没进来 if.
        return 'A'.char() + val as u8 - 10
    }
    return '0'.char()
}

fn main() {
    var temp = int_to_hex(14)
    assert(temp == 69)

    temp = int_to_hex(11)
    assert(temp == 66)
}

=== test_interface_have_reset
--- main.n
type connable = interface{
    fn query(string sql, ...[string] args):[string]
}

type connable2 = interface{
    fn query(string, ...[string]):[string]
}

fn main() {
    println('hello world')
}

--- output.txt
hello world

=== test_type_fn_param_name
--- main.n
type connable = interface{
    fn query(string name, ...[string]):[string]
}

fn main() {
    println('hello world')
}

--- output.txt
nature-test/main.n:2:39: fn with both named and unnamed formal parameters

=== test_union_failed
--- main.n
type uniona = int|f32
type unionb = int|f32|string

fn main() {
    unionb b = 'hello'
    uniona a = b
}

--- output.txt
nature-test/main.n:6:16: type inconsistency, expect=main.uniona(union), actual=main.unionb(union)

=== test_union
--- main.n
type uniona = int|f32
type unionb = int|f32|string

fn main() {
    uniona b = 3.14 as f32
    unionb a = b
}

=== test_type_ident
--- main.n
type test_t = struct{
    int foo
}

fn test_t.set(int a) {
    self.foo = a
}

fn test_t.map() {
    self.foo = 24
}

fn test_t.vec() {
    println('hello world')
}

fn main() {
    var t = test_t{}
    t.set(12)
    println(t.foo)
    t.vec()
}

--- output.txt
12
hello world

=== test_as_failed
--- main.n
type handle_fn = fn(int):void!

fn main() {
    any arg = (fn(int a, int b):void!{
        a = 12
    }) as handle_fn

    if arg is handle_fn {
        println('hello world')
    }
}

--- output.txt
nature-test/main.n:4:17: cannot casting to 'main.handle_fn(fn(...):void!)'
